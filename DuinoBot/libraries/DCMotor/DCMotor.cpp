/* 	DCMotor



	A small DC motor control class.



	Copyright (C) 2010-2012 Multiplo

	http://robotgroup.com.ar

	http://multiplo.org

	Developers: JuliÃ¡n U. da Silva Gillig

	Created: 2010.04.06 (yyyy.mm.dd)

	Last modified: 2012.11.13 (yyyy.mm.dd)



	IMPORTANT NOTICE: This library is based on code from the SNAPI library, which is under The Multiplo

	Pacifist License (MPL). This license is (or may be) not compatible with the GNU Lesser General Public

	License (LGPL), so this notice constitutes an special written exception from Multiplo, to allow deployment

	under the LGPL, in order to be compiled with the Arduino libraries and still hold compatibility	between

	both licenses.

	But this does not affects the SNAPI original license in any way, and DOES NOT AUTHORIZES ANY THIRD PARTY

	TO USE OR REDISTRIBUTE THE SNAPI LIBRARY UNDER THE LGPL. In other words: This exception ONLY AFFECTS the

	library when compiled with Arduino libraries, if and only if, this license (the MPL) results in some

	inconpatibility with the LGPL (so in this last case, then LGPL applies):



        This library is free software; you can redistribute it and/or

        modify it under the terms of the GNU Lesser General Public

        License as published by the Free Software Foundation; either

        version 2.1 of the License, or (at your option) any later version.



        This library is distributed in the hope that it will be useful,

        but WITHOUT ANY WARRANTY; without even the implied warranty of

        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU

        Lesser General Public License for more details.



    Any way, we strongly believe in peace, so we would not like to see our work in any non-civil or military

    project. But, due to the possible incompatibilty with the LGPL licenses, this may be only a recommendation

    and an expression of our wishes. But, if some clever guy can determine that LGPL and MPL are compatible

    licenses, then MPL applies here. You can contact us at: info_t1@multiplo.com.ar

*/



#include "DCMotor.h"





const int maxPWMValue = 255;



struct DCMotor DCMotor_create(const int enable_pin, const int d0_pin, const int d1_pin, int clockwise)
{
	struct DCMotor motor;
	motor.clockwise = clockwise;
	motor.braked    = 0;
	motor.speed     = 0;
	motor.prevSpeed = 0;
	motor.zeroZone  = 0.1;
	motor.enable_pin = enable_pin;
	motor.d0_pin     = d0_pin;
	motor.d1_pin     = d1_pin;
	pinMode(motor.enable_pin, OUTPUT);
	pinMode(motor.d0_pin, OUTPUT);
	pinMode(motor.d1_pin, OUTPUT);
	digitalWrite(motor.enable_pin, LOW);
	digitalWrite(motor.d0_pin, LOW);
	digitalWrite(motor.d1_pin, LOW);
	return motor;
}

void DCMotor_setSpeed(struct DCMotor* m,const float value)
{

	float tempSpeed = constrain(value, dcMotMinSpeed, dcMotMaxSpeed);
	m->prevSpeed = m->speed;
	m->speed = tempSpeed;
	if (!m->clockwise)
		tempSpeed = (-tempSpeed);

	tempSpeed = (tempSpeed/dcMotMaxSpeed)*maxPWMValue;



	if (tempSpeed > m->zeroZone)   {
		//Forward:
#if defined(DUINOBOT_V1X) || defined(DUINOBOT_V1X_HID) || defined(DUINOBOT_KITS_V1X)
		if (abs(tempSpeed - m->prevSpeed) >= 25) delay(MOTOR_DELAY_TB6612);
#endif
		digitalWrite(m->d0_pin, HIGH); //First sets the direction.
		digitalWrite(m->d1_pin, LOW);
		analogWrite(m->enable_pin, (int)tempSpeed); //Then sets the PWM's duty cycle.
	}  else if (tempSpeed < -m->zeroZone)   {
		//Reverse:
#if defined(DUINOBOT_V1X) || defined(DUINOBOT_V1X_HID) || defined(DUINOBOT_KITS_V1X)
		if (abs(tempSpeed - m->prevSpeed) >= 25) delay(MOTOR_DELAY_TB6612);
#endif
		digitalWrite(m->d0_pin, LOW);
		digitalWrite(m->d1_pin, HIGH);
		analogWrite(m->enable_pin, (int)(-tempSpeed));
	}   else { /*(tempSpeed == 0)   */
		//Free-running:
		analogWrite(m->enable_pin, 0);		//To avoid a possible glitch generated by the PWM timer
		//after the next instruccion.
		digitalWrite(m->enable_pin, LOW);  //This line would be enough, but the following ensures
		digitalWrite(m->d0_pin, LOW);      //the full state of the H-bridge, so if someone writes
		digitalWrite(m->d1_pin, LOW);      //a HIGH to the enable_pin, the state will be "Braked".
		//And in some H-bridge chips (such as the TB6612FGN
		//this is necessary.
	}
	m->braked = false;

}

void DCMotor_brake(struct DCMotor* m)

{

	digitalWrite(m->d0_pin, HIGH);
	digitalWrite(m->d1_pin, HIGH);
	digitalWrite(m->enable_pin, HIGH); //This stops the analogWrite (PWM) for the enable_pin.
	m->braked = true;

}

void DCMotor_setClockwise(struct DCMotor *m,int  value)
{

	m->clockwise = value;
	if (!m->braked)
		DCMotor_setSpeed(m,m->speed);
}
